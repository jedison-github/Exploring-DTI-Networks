r=exp(logR)
r[is.nan(r)]=0
e=pmin(1, r)
u=runif(k, 0, 1)
alpha.est[u<=e & alpha.est.test>1]=alpha.est.test[u<=e & alpha.est.test>1]
#acceptance rate
e.record[, i]=e
alpha.record[, i]=alpha.est
#update X
X=apply(U, c(1,2), Qinverse)
}
A=matrix(c(4,-1,2,1), ncol = 2)
View(A)
A-I
A-E
A
A=matrix(c(3,-1,2,3), ncol = 2)
A
interM=solve(A)
interM
A=matrix(c(3,-1,2,0), ncol = 2)
interM=solve(A)
interM
v0=c(1,0)
v1=interM%*%v0
v1
lamd=function(vn, vn1){
1+t(vn)%*%vn/(t(vn)%*%vn1)
}
lamd(v0,v1)
scale(v1)
?scale
v1
A=matrix(c(-1,0,0,-2,0,3,1,0,0,-1,1,0,1,0,0,2), ncol = 4)
A
eigen(A)
I
M=matrix(c(1/2,1/2,0,1/2,0,1/2,0,0,1),ncol = 3)
R=c(1/3,1/3,1/3)
r=c(1,1,1)
while (max(abs(R-r))>0.001) {
r=R
R=M%*%R
R=0.8*R+0.2*1/3*c(1,1,1)
}
R
matrix(c(rep(1/3,9)), ncol = 3)
M=matrix(c(1/2,1/2,0,1/2,0,1/2,0,0,1),ncol = 3)
M=0.8*M+0.2*matrix(c(rep(1/3,9)), ncol = 3)
R=c(1/3,1/3,1/3)
r=c(1,1,1)
while (max(abs(R-r))>0.001) {
r=R
R=M%*%R
}
R
gamma(0)
gamma(1)
library(MASS)
library(MCMCpack)
library(mvtnorm)
#library(GoFKernel)
p=3
f=function(u){
gamma(p/2)/(2*pi^(p/2))*2*sum(
lamda.est/(alpha.est-1)*(1-pgamma(abs(u), alpha.est-1, lamda.est)) *p.est)
}
f2=Vectorize(f)
Q=function(x){
1/2+pi^((p-1)/2)/(gamma((p-1)/2))*integrate(f2, 0, x)[[1]]
}
Qinverse=function(y)
{
optim(0, (function(x) abs(Q(x) - y)), method = "L-BFGS-B")$par
}
#Two dimension data generation
n=500
rho12=.5
rho13=.6
rho23=.7
dimention=3
omega=matrix(c(1,rho12, rho13, rho12, 1, rho23, rho13, rho23,1), nrow=dimention)
#Generate trivariate normal
Z=mvrnorm(n, c(0,0,0), omega)
X.star=matrix(c(qt(pnorm(Z[,1], log.p = TRUE),df=1,log.p = TRUE),
qt(pnorm(Z[,2], log.p = TRUE),df=2,log.p = TRUE),
qt(pnorm(Z[,2], log.p = TRUE),df=1,log.p = TRUE)), ncol = 3)
n=nrow(X.star)
dimension=ncol(X.star)
#Fixed rho for elliptical
omega.est=omega
#######MCMC based on rho and R
########################################
k=30 # Indicating infinite number of components
v=rbeta(k-1, 1, 1)
v=c(v,1)
#compute P
p.est=vector(mode="double", length = k)
sum=0
for (i in 1:k) {
p.est[i]=(1-sum)*v[i]
sum=sum+p.est[i]
}
#Prior of alpha
rpareto <- function(n,c){
if(c<=0) stop("c must be positive")
rp <- runif(n)^(-1/c)
rp}
c=3 # how to set it up
#Prior of lamda, which is gamma dist
alpha.null=1
lamda.null=1
#initialized alpha and lamda
alpha.est=c(rep(1.1,k))
lamda.est=c(rep(1,k))
#transform X.star into X by initial Q
X=matrix(data=NA, nrow =nrow(X.star) , ncol = ncol(X.star))
U=matrix(c(pt(X.star[,1], df=1),pt(X.star[,2], df=2),pt(X.star[,3], df=2)),
ncol = 3)
U=round(U,2)
U[U>0.99]=0.99
U[U<0.01]=0.01
X=apply(U, c(1,2), Qinverse)
load("~/MASTERThesis/code/Result/resulttrivn1.RData")
p=3
f=function(u){
gamma(p/2)/(2*pi^(p/2))*2*sum(
lamda.est/(alpha.est-1)*(1-pgamma(abs(u), alpha.est-1, lamda.est)) *p.est)
}
f2=Vectorize(f)
Q=function(x){
1/2+pi^((p-1)/2)/(gamma((p-1)/2))*integrate(f2, 0, x)[[1]]
}
Qinverse=function(y)
{
optim(0, (function(x) abs(Q(x) - y)), method = "L-BFGS-B")$par
}
x=seq(-5,5,0.1)
plot(x, Q(x))
Q=Vectorize(Q)
plot(x, Q(x))
alpha.est=alpha.record[2000]
lamda.est=lamda.record[2000]
seq(-5,5,0.1)
plot(x, Q(x))
p.est=p.record[2000]
plot(x, Q(x))
plot(x, norm(x))
plot(x, pnorm(x))
library(MASS)
library(MCMCpack)
library(mvtnorm)
#library(GoFKernel)
p=3
f=function(u){
gamma(p/2)/(2*pi^(p/2))*2*sum(
lamda.est/(alpha.est-1)*(1-pgamma(abs(u), alpha.est-1, lamda.est)) *p.est)
}
f2=Vectorize(f)
Q=function(x){
1/2+pi^((p-1)/2)/(gamma((p-1)/2))*integrate(f2, 0, x)[[1]]
}
Q=Vectorize(Q)
Qinverse=function(y)
{
optim(0, (function(x) abs(Q(x) - y)), method = "L-BFGS-B")$par
}
n=200
rho12=.5
rho13=.6
rho23=.7
dimention=3
omega=matrix(c(1,rho12, rho13, rho12, 1, rho23, rho13, rho23,1), nrow=dimention)
#Generate trivariate normal
Z=mvrnorm(n, c(0,0,0), omega)
X.star=matrix(c(qt(pnorm(Z[,1], log.p = TRUE),df=1,log.p = TRUE),
qt(pnorm(Z[,2], log.p = TRUE),df=2,log.p = TRUE),
qt(pnorm(Z[,2], log.p = TRUE),df=1,log.p = TRUE)), ncol = 3)
n=nrow(X.star)
dimension=ncol(X.star)
#########################################
#####estimation##############
#Fixed rho for elliptical
omega.est=omega
#######MCMC based on rho and R
########################################
k=30 # Indicating infinite number of components
v=rbeta(k-1, 1, 1)
v=c(v,1)
#compute P
p.est=vector(mode="double", length = k)
sum=0
for (i in 1:k) {
p.est[i]=(1-sum)*v[i]
sum=sum+p.est[i]
}
#Prior of alpha
rpareto <- function(n,c){
if(c<=0) stop("c must be positive")
rp <- runif(n)^(-1/c)
rp}
c=3 # how to set it up
#Prior of lamda, which is gamma dist
alpha.null=1
lamda.null=1
#initialized alpha and lamda
alpha.est=c(rep(1.1,k))
lamda.est=c(rep(1,k))
############################################################
#transform X.star into X by initial Q
X=matrix(data=NA, nrow =nrow(X.star) , ncol = ncol(X.star))
U=matrix(c(pt(X.star[,1], df=1),pt(X.star[,2], df=2),pt(X.star[,3], df=2)),
ncol = 3)
U=round(U,2)
U[U>0.99]=0.99
U[U<0.01]=0.01
X=apply(U, c(1,2), Qinverse)
hist(X)
?glm
M=matrix(c(0,0,1/2,1/2,0,
0,0,0,0,1,
0,0,0,1/2,0,
1/2,1,1/2,0,0,
1/2,0,0,0,0), ncol = 5, byrow = TRUE)
M
R=c(1/5,1/5,1/5,1/5,1/5)
r=c(1,1,1,1,1)
while (max(abs(R-r))>0.001) {
r=R
R=M%*%R
}
R
r
M=matrix(c(0,0,1/2,1/2,0,
0,0,0,0,1,
0,0,0,1/2,0,
1/2,1,1/2,0,0,
1/2,0,0,0,0), ncol = 5, byrow = TRUE)
R=c(1/5,1/5,1/5,1/5,1/5)
for (i in 1:4) {
R=M%*%R
}
R
View(M)
M
M=matrix(c(0,0,1/2,1/2,0,
0,0,0,0,1,
0,0,0,1/2,0,
1/2,1,1/2,0,0,
1/2,0,0,0,0), ncol = 5, byrow = TRUE)
R=c(1/5,1/5,1/5,1/5,1/5)
r=c(1,1,1,1,1)
for (i in 1:4) {
R=M%*%R
R
}
R
for (i in 1:4) {
R=M%*%R
R
}
for (i in 1:4) {
R=M%*%R
R
}
x=seq(0,8,0.1)
y=plogis(-2*x+8)
M=matrix(c(0,0,1/2,1/2,0,
0,0,0,0,1,
0,0,0,1/2,0,
1/2,1,1/2,0,0,
1/2,0,0,0,0), ncol = 5, byrow = TRUE)
R=c(1/5,1/5,1/5,1/5,1/5)
for (i in 1:4) {
R=M%*%R
R
}
for (i in 1:4) {
M%*%R
}
while (max(abs(R-r))>0.001) {
r=R
M%*%R
}
M=matrix(c(0,0,1/2,1/2,0,
0,0,0,0,1,
0,0,0,1/2,0,
1/2,1,1/2,0,0,
1/2,0,0,0,0), ncol = 5, byrow = TRUE)
R=c(1/5,1/5,1/5,1/5,1/5)
M%*%R
M%*%R
M=matrix(c(0,0,1/2,1/2,0,
0,0,0,0,1,
0,0,0,1/2,0,
1/2,1,1/2,0,0,
1/2,0,0,0,0), ncol = 5, byrow = TRUE)
R=c(1/5,1/5,1/5,1/5,1/5)
R=M%*%R
R
R=M%*%R
R
R=M%*%R
R
R=M%*%R
R
gamma()
?gamma
?gammainc
install.packages("pracma")
#library(GoFKernel)
library(pracma)
load("~/.RData")
load("~/MASTERThesis/code/.RData")
alpha.est
lamda.est
z=2
lamda.est*z
t=1
lamda.est*z*t
alpha.est+1
gammainc(alpha.est+1, lamda.est*z*t)
gammaincv=Vectorize(gammainc)
gammainc(alpha.est+1, lamda.est*z*t)
gammaincv(alpha.est+1, lamda.est*z*t)
?gammainc
incgam(alpha.est+1, lamda.est*z*t)
incgamv=Vectorize(incgam)
incgamv(alpha.est+1, lamda.est*z*t)
gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t)
(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est
1/(alpha.est-1)*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est
sqrt(t)*1/(alpha.est-1)*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est
f=Vectorize(f)
f=function(t){
sqrt(t)*1/(alpha.est-1)*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est
}
f=Vectorize(f)
Q=function(z){
1/2+pi^(-1/2)*gamma(3/2)*integrate(f,1,Inf)
}
Q(2)
Q=function(z){
1/2+pi^(-1/2)*gamma(3/2)*integrate(f,1,Inf)[[1]]
}
Q(2)
f=function(t){
sqrt(t)*1/(alpha.est-1)*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est
}
f2=Vectorize(f)
Q=function(z){
1/2+pi^(-1/2)*gamma(3/2)*integrate(f2,1,Inf)[[1]]
}
Q(2)
sqrt(t)*1/(alpha.est-1)*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est
f=function(t){
sum(sqrt(t)*1/(alpha.est-1)*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est)
}
f2=Vectorize(f)
Q=function(z){
1/2+pi^(-1/2)*gamma(3/2)*integrate(f2,1,Inf)[[1]]
}
Q(2)
sum(sqrt(t)*1/(alpha.est-1)*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est)
z=2
f(1)
f(1000)
f=function(t){
sum(sqrt(t)*1/(gamma(alpha.est)*(alpha.est-1))*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est)
}
f(1000)
sum(sqrt(t)*1/(gamma(alpha.est)*(alpha.est-1))*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est)
f(100)
f(50)
f(3)
f=function(t){
sum(t^(-2)*1/(gamma(alpha.est)*(alpha.est-1))*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est)
}
sum(t^(-2)*1/(gamma(alpha.est)*(alpha.est-1))*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est)
f(3)
f(50)
z
f=function(t){
sum(t^(-2)*1/(gamma(alpha.est)*(alpha.est-1))*(gamma(alpha.est+1)+incgamv(alpha.est+1, lamda.est*z*t))*p.est)
}
f2=Vectorize(f)
Q=function(z){
1/2+pi^(-1/2)*gamma(3/2)*integrate(f2,1,Inf)[[1]]
}
Q(2)
setwd("~/Exploring-DTI-Networks/data/ligand_smiles")
Filenames=list.files(path = "GPCRs/")
Alist=vector(length = length(Filenames))
for (i in 1:length(Filenames)) {
Alist[i]=strsplit(Filenames[i],split='_', fixed=TRUE)[[1]][1]
}
Blist=c()
for (j in 1: length(Filenames)){
Blist=c(Blist,read.csv(file=paste("GPCRs/",Filenames[j], sep = ""))[,1])
}
Blist=unique(Blist)
interaction=data.frame(matrix(ncol = length(Alist), nrow = length(Blist)))
colnames(interaction)=Alist
rownames(interaction)=Blist
j=1
temp=read.csv(file=paste("GPCRs/",Filenames[j], sep = ""))
id=temp[,1]
activity=temp[,5]
interaction[id,j]=activity
View(interaction)
interaction[,1]
interaction[,1]!=0
interaction[,1]!=NA
interaction[1:10,1:10]
temp[,5]
interaction[id,j]
j
id
activity
interaction[,1]
interaction[,j]
id
interaction[id,1:10]
temp[,1]
interaction[1:10,1:10]
interaction["2043490",1]
interaction["2043490",1]=1
interaction[1:10,1:10]
id
string(id)
toString(id)
interaction[toString(id),j]=activity
interaction[toString(id),j]
toString(id)
j
temp=read.csv(file=paste("GPCRs/",Filenames[j], sep = ""))
id=temp[,1]
interaction[as.character(id),j]=activity
interaction[1:10,1:10]
as.character(id)
interaction[1:15,1:10]
Filenames=list.files(path = "GPCRs/")
Alist=vector(length = length(Filenames))
for (i in 1:length(Filenames)) {
Alist[i]=strsplit(Filenames[i],split='_', fixed=TRUE)[[1]][1]
}
Blist=c()
for (j in 1: length(Filenames)){
Blist=c(Blist,read.csv(file=paste("GPCRs/",Filenames[j], sep = ""))[,1])
}
Blist=unique(Blist)
interaction=data.frame(matrix(ncol = length(Alist), nrow = length(Blist)))
colnames(interaction)=Alist
rownames(interaction)=Blist
for (j in 1: length(Filenames)){
temp=read.csv(file=paste("GPCRs/",Filenames[j], sep = ""))
id=temp[,1]
activity=temp[,5]
interaction[as.character(id),j]=activity
}
interaction[1:20,1:10]
write.csv(interaction, file = "GPCRsInteraction.csv")
Filenames=list.files(path = "ion-channels/")
Alist=vector(length = length(Filenames))
for (i in 1:length(Filenames)) {
Alist[i]=strsplit(Filenames[i],split='_', fixed=TRUE)[[1]][1]
}
Blist=c()
for (j in 1: length(Filenames)){
Blist=c(Blist,read.csv(file=paste("ion-channels/",Filenames[j], sep = ""))[,1])
}
Blist=unique(Blist)
interaction=data.frame(matrix(ncol = length(Alist), nrow = length(Blist)))
colnames(interaction)=Alist
rownames(interaction)=Blist
for (j in 1: length(Filenames)){
temp=read.csv(file=paste("ion-channels/",Filenames[j], sep = ""))
id=temp[,1]
activity=temp[,5]
interaction[as.character(id),j]=activity
}
write.csv(interaction, file = "ion-channelsInteraction.csv")
interactionMatrix=function(directory){
directoryPath=paste(directory, "/", sep = "")
Filenames=list.files(path = directoryPath)
#read file names as Protein names
Alist=vector(length = length(Filenames))
for (i in 1:length(Filenames)) {
Alist[i]=strsplit(Filenames[i],split='_', fixed=TRUE)[[1]][1]
}
#Read all drug ids
Blist=c()
for (j in 1: length(Filenames)){
Blist=c(Blist,read.csv(file=paste(directoryPath,Filenames[j], sep = ""))[,1])
}
Blist=unique(Blist)
#build an empty interaction matrix
interaction=data.frame(matrix(ncol = length(Alist), nrow = length(Blist)))
colnames(interaction)=Alist
rownames(interaction)=Blist
#fill activity value in the interaction matrix
for (j in 1: length(Filenames)){
temp=read.csv(file=paste(directoryPath,Filenames[j], sep = ""))
id=temp[,1]
activity=temp[,5]
interaction[as.character(id),j]=activity
}
write.csv(interaction, file =paste(directory,"Interaction.csv", sep = ""))
}
interaction.plot("kinases")
interactionMatrix("kinases")
interactionMatrix("nuclear-hormone-receptors")
